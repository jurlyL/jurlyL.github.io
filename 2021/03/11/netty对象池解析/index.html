<!DOCTYPE html><html lang="en"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><title>Netty对象池 | Jurly's Shell</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/normalize.css/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/clipboard/dist/clipboard.min.js"></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.js"></script><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.css"><meta name="generator" content="Hexo 5.4.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Netty对象池</h1><a id="logo" href="/.">Jurly's Shell</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> Home</i></a><a href="/archives/"><i class="fa fa-archive"> Archive</i></a><a href="/about/"><i class="fa fa-user"> About</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Netty对象池</h1><div class="post-meta">2021-03-11<span> | </span><span class="category"><a href="/categories/Netty/">Netty</a></span></div><div class="post-content"><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>当你看到这篇博客时候，说明你已经知道什么是对象池了，这儿就不啰嗦了。</p>
<p>对象池好处：</p>
<ul>
<li>减少新建对象的损耗(可以看下new一个对象时候jvm里发生了什么)</li>
<li>减少GC频率</li>
</ul>
<p>Netty作为一个高性能网络框架，作者对性能的追求在我看来也是达到了“变态”的级别，所以Netty也自然也实现了自己的对象池。这篇博客儿就浅入浅出的说下netty的对象池(不敢妄称深入哈哈哈)。</p>
<h3 id="一、整体结构"><a href="#一、整体结构" class="headerlink" title="一、整体结构"></a>一、整体结构</h3><p>先上一个大体结构图，这段有个印象就行，不必纠结是否看懂，下面结合源码详细的来分析，然后再回来看。</p>
<p><img src="https://jurlyl.github.io/img/1615476761452-5d49235d-d5da-4d66-9079-c92669a07185.png" alt="1615476761452-5d49235d-d5da-4d66-9079-c92669a07185"></p>
<p>图中的各个组件：</p>
<p><strong>Stack:</strong> netty自己实现的一个栈，是<strong>线程的本地变量</strong>，用于存放stack所属线程回收的对象(包装过的)。比如Stack1是线程1的本地变量，那么线程1回收的对象就存放在Stack中。Stack主要结构如下：</p>
<ul>
<li>DefaultHandle[] <strong>elements</strong>，一个handle数组，是Stack的成员变量。这个数组就是Stack底层的数据结构。而<strong>DefaultH****andle是netty对于对象的包装</strong>，handle里面有一个成员变量value，这个value就是真正的对象。<strong>每个handle都绑定了一个Stack</strong>。</li>
<li>head。这个成员变量是WeakOrderQueue类型的。指向一个WeakOrderQueue实例。prev和cursor类似。</li>
</ul>
<p><strong>WeakOrderQueue</strong>：netty实现的一个数据，用于 <strong>存放 当前线程回收的 与 非当前线程的本地变量stack绑定的 Handle对象(<strong>好像绕口令</strong>)<strong>。比如，handle1绑定的是线程1的本地变量stack1，而进行回收时候，是由线程2进行的，那么线程2就会创建一个WeakOrderQueue（假设名字为queue1）来存放handle1，并且以头插的方式把这个queue1插入到以stack的head成员变量为头部的weakOrderQueue链表中。然后以stack1为key，queue1为value，插入到自己的本地变量</strong>Map&lt;Stack&lt;?&gt;,WeakOrderQueue&gt; delayedRecycled（</strong>这个变量源码里叫<em>DELAYED_RECYCLED**</em>）**中。后续如果还要继续回收和stack1绑定的handle，就直接以stack1为key，从这个map中取出stack1对应的queue1，然后把queue放到queue1里。</p>
<p>weakOrderQueue的结构如下：</p>
<ul>
<li><strong>LINK</strong>：weakOrderQueue底层是Link链表，link底层是一个handle[]数组。</li>
<li><strong>HEAD</strong>：特殊的头节点，底层是一个handle。</li>
</ul>
<h3 id="二、源码分析"><a href="#二、源码分析" class="headerlink" title="二、源码分析"></a>二、源码分析</h3><p>Netty的对象池封装在Recycler这个抽象类里。netty的doc。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Light-weight object pool based on a thread-local stack</span><br></pre></td></tr></table></figure>

<p>基于线程本地栈的轻量级线程池。这个类结构如下：</p>
<p><img src="https://jurlyl.github.io/img/1615395703629-b8074049-b5c5-4e88-86fa-8739d207909a.png" alt="image.png"></p>
<p>除了一堆成员变量和构造方法外，重要的有两个方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;从池子中取出一个对象</span><br><span class="line">public final T get() &#123;&#x2F;&#x2F;此处省略方法体&#125;；</span><br><span class="line">&#x2F;&#x2F;new一个对象，由子类实现</span><br><span class="line">protected abstract T newObject(Handle&lt;T&gt; handle);</span><br></pre></td></tr></table></figure>

<p>最后还有四个内部类：</p>
<ul>
<li>Defaulthandle.</li>
<li>Handle</li>
<li>Stack</li>
<li>WeakOrderQueue</li>
</ul>
<p>对这个类有个整体的印象后，就开始往下看源码吧~</p>
<h4 id="2-1-获取对象"><a href="#2-1-获取对象" class="headerlink" title="2.1 获取对象"></a>2.1 获取对象</h4><p>Recycler里获取对象方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public final T get() &#123;</span><br><span class="line">        &#x2F;&#x2F;maxCapacityPerThread为0时候，代表不允许对对象进行回收</span><br><span class="line">        &#x2F;&#x2F;创建一个对象，其Recycler.Handle&lt;User&gt; handle属性为NOOP_HANDLE，该对象的recycle(Object object)不做任何事情，即不做回收</span><br><span class="line">        if (maxCapacityPerThread &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            &#x2F;&#x2F;NOOP_HADNLE是一个不会进行回收的handle</span><br><span class="line">            return newObject((Handle&lt;T&gt;) NOOP_HANDLE);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;拿到当前线程的FastThreadLocal中的Stack</span><br><span class="line">        Stack&lt;T&gt; stack &#x3D; threadLocal.get();</span><br><span class="line">        &#x2F;&#x2F;从stack中弹出一个handle</span><br><span class="line">        DefaultHandle&lt;T&gt; handle &#x3D; stack.pop();</span><br><span class="line">        &#x2F;&#x2F;如果handle为空就new一个对象返回，否则就直接把handle持有的value，也就是真正的对象给返回</span><br><span class="line">        if (handle &#x3D;&#x3D; null) &#123;</span><br><span class="line">            handle &#x3D; stack.newHandle();</span><br><span class="line">            handle.value &#x3D; newObject(handle);</span><br><span class="line">        &#125;</span><br><span class="line">        return (T) handle.value;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>handle是Recyler中的一个内部接口，它只有一个实现，<strong>DefaultHandle</strong>类，下文中的所有handle指得都是DefaultHandle。DefaultHandle包装了真正对象，便于对对象进行回收。它内部持有一个value成员变量，这个value就是对象池中真正的对象，recycle方法就是回收对象的方法。<strong>注意，DefaultHandle的构造方法是必须传一个Stack对象进去的！！！这就意味着，每个Handle对象都和一个Stack进行了绑定，Handle是被哪个线程创建的，就和哪个线程的Stack进行绑定</strong>。其结构如下：</p>
<p><img src="https://jurlyl.github.io/img/1615465354440-e19fadd4-b169-4414-a8a2-a1a46f826c38.png" alt="image.png"></p>
<p>总结以下get方法，主要步骤是：</p>
<p>1） 判断maxCapacityPerThread成员变量是否为0，当这个变量为0时候，代表不允许对对象进行回收，那么池子中就没有对象，所以直接创建一个对象返回。</p>
<p>2）拿到当前线程的Stack。</p>
<p>3）从上面拿到的Stack中取出一个Handle</p>
<p>4）判断handle是否为空，如果是的话，直接new一个对象返回，不是的话就返回handle的value。也就是真正的对象。</p>
<p>以上步骤中，最重要的方法就是stack.pop()。我们来继续看pop方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">DefaultHandle&lt;T&gt; pop() &#123;</span><br><span class="line">            &#x2F;&#x2F;当前stack中有多少对象</span><br><span class="line">            int size &#x3D; this.size;</span><br><span class="line">            &#x2F;&#x2F;如果size&#x3D;&#x3D;0，说明当前栈中没有对象了</span><br><span class="line">            if (size &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                &#x2F;&#x2F;把被其他线程回收的对象转移到stack</span><br><span class="line">                if (!scavenge()) &#123;</span><br><span class="line">                    return null;</span><br><span class="line">                &#125;</span><br><span class="line">                size &#x3D; this.size;</span><br><span class="line">                if (size &lt;&#x3D; 0) &#123;</span><br><span class="line">                    &#x2F;&#x2F; double check, avoid races</span><br><span class="line">                    return null;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            size --;</span><br><span class="line">            DefaultHandle ret &#x3D; elements[size];</span><br><span class="line">            elements[size] &#x3D; null;</span><br><span class="line">            &#x2F;&#x2F; As we already set the element[size] to null we also need to store the updated size before we do</span><br><span class="line">            &#x2F;&#x2F; any validation. Otherwise we may see a null value when later try to pop again without a new element</span><br><span class="line">            &#x2F;&#x2F; added before.</span><br><span class="line">            this.size &#x3D; size;</span><br><span class="line"></span><br><span class="line">            if (ret.lastRecycledId !&#x3D; ret.recycleId) &#123;</span><br><span class="line">                throw new IllegalStateException(&quot;recycled multiple times&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            ret.recycleId &#x3D; 0;</span><br><span class="line">            ret.lastRecycledId &#x3D; 0;</span><br><span class="line">            return ret;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>pop方法的步骤如下：</p>
<p>1）判断当前stack中的元素个数size是否为0，是的话就调用<strong>scavenge()<strong>方法。</strong>这个方法作用是把其他线程回收的与当前stack绑定的对象转移到当前stack**<strong>中</strong></strong>(<strong>当前stack指的是，当前线程Thread.currentThread的本地变量Stack</strong>)**。</p>
<p>2)如果Stack.size&gt;0，也就是Stack中还有对象，那么就把size–，并且拿到Stack底层数组DefaultHandle[] elements数组中的最后一个元素ret，然后把这个数组最后一个位置置为null。再更新Stack的size值。</p>
<p>3）判断handle对象的lastRecycleId和recycledId是否相等。这俩成员变量作用就是标记对象是否被回收过。</p>
<p>4）把recycledId和lastRecycledId置为0，并且把ret返回。</p>
<p>这儿就先跳过<strong>scavenge()方法</strong>怎么把被其他线程回收的对象转移到当前stack。先看怎么回收对象的，然后再看scavenge（）方法。</p>
<h3 id="2-2-回收对象"><a href="#2-2-回收对象" class="headerlink" title="2.2 回收对象"></a>2.2 回收对象</h3><p>回收对象的方法在上面提到过，是在DefaultHandle中。这儿再看下DefaultHandle的部分结构，<strong>构造方法传入了一个Stack，也就是说每个DefaultHandle都绑定了一个Stack，而且这个Stack就是创建Handle对象的线程所持有的Stack。</strong>这是第二次说…因为这点真的很重要。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private static final class DefaultHandle&lt;T&gt; implements Handle&lt;T&gt; &#123;</span><br><span class="line">    Stack&lt;?&gt; stack;</span><br><span class="line">    Object value;</span><br><span class="line"></span><br><span class="line">    DefaultHandle(Stack&lt;?&gt; stack) &#123;</span><br><span class="line">        this.stack &#x3D; stack;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 对象回收</span><br><span class="line">     * @param object</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @Override</span><br><span class="line">    public void recycle(Object object) &#123;&#x2F;&#x2F;省略方法体&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>然后再看handle如何回收对象，举个栗子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Foo &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private Recycler.Handle&lt;Foo&gt; handle;</span><br><span class="line"></span><br><span class="line">    public Foo(Recycler.Handle&lt;Foo&gt; handle) &#123;</span><br><span class="line">        this.handle &#x3D; handle;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void recycle() &#123;</span><br><span class="line">        handle.recycle(this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Foo这个类持有一个Handle成员变量，在构造Foo的时候传入一个handle对象。当new出一个foo对象后，可以调用这个handle的recycle方法对foo进行回收。</p>
<p>接下来就来看DefaultHandle的回收方法recycle(),代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public void recycle(Object object) &#123;</span><br><span class="line">            &#x2F;&#x2F;如果要回收的对象不等于当前Handle持有的value，就回收不了</span><br><span class="line">            if (object !&#x3D; value) &#123;</span><br><span class="line">                throw new IllegalArgumentException(&quot;object does not belong to handle&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;拿到当前Handle绑定的Stack</span><br><span class="line">            Stack&lt;?&gt; stack &#x3D; this.stack;</span><br><span class="line">            &#x2F;&#x2F;判断对象是否已经被回收</span><br><span class="line">            if (lastRecycledId !&#x3D; recycleId || stack &#x3D;&#x3D; null) &#123;</span><br><span class="line">                throw new IllegalStateException(&quot;recycled already&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;把对象压入栈</span><br><span class="line">            stack.push(this);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>这个方法的主要步骤如下：</p>
<p>1）判断要回收的对象是否和是当前handle所持有的value。不是就抛出异常。</p>
<p>2）拿到当前Handle绑定的Stack。上面说过，每个DefaultHandle在构造时候都传入了一个Stack。</p>
<p>3）判断对象是否已经被回收过，是就抛异常，不是就继续往下走。</p>
<p>3）把this，也就是当前handle对象压入和它绑定的Stack中。</p>
<p>以上步骤的重点就是最后一步，把handle压栈。那我们继续来看stack.push()。先别纠结这段代码注释，看不懂往下看就行~</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">void push(DefaultHandle&lt;?&gt; item) &#123;</span><br><span class="line">    Thread currentThread &#x3D; Thread.currentThread();</span><br><span class="line">    &#x2F;&#x2F;如果当前线程执行回收对象的线程是当前stack绑定的线程</span><br><span class="line">    &#x2F;&#x2F;就执行pushnow，也就是把对象压入当前Stack</span><br><span class="line">    if (threadRef.get() &#x3D;&#x3D; currentThread) &#123;</span><br><span class="line">        &#x2F;&#x2F; The current Thread is the thread that belongs to the Stack, we can try to push the object now.</span><br><span class="line">        pushNow(item);</span><br><span class="line">     &#x2F;&#x2F;否则，就执行pushLater，把对象放到WeakOrderQueue中，并且把WeakOrderQueue插入这个handle绑定的Stack中的WeakOrderQueue链表</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F; The current Thread is not the one that belongs to the Stack</span><br><span class="line">        &#x2F;&#x2F; (or the Thread that belonged to the Stack was collected already), we need to signal that the push</span><br><span class="line">        &#x2F;&#x2F; happens later.</span><br><span class="line">        pushLater(item, currentThread);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先，这个push方法是在Stack类中的。threadRef是Stack类的一个成员变量，代表这个Stack是哪个线程的本地变量(后面我会用绑定这个词，比如Stack和哪个线程绑定，意思等同于Stack是哪个线程的本地变量)。</p>
<p>push方法步骤如下：</p>
<p>1）判断当前执行push方法（回收对象）的线程是否是Stack绑定的线程。</p>
<p>2）如果是，就调用pushNow(item)方法。这个方法是Stack绑定的线程来回收对象如何处理。</p>
<p>3）如果不是，就调用pushLater(item)方法。这个方法是非Stack绑定的线程来回收对象如何处理。</p>
<p>接下来就详细分析这俩方法。</p>
<h5 id="2-2-1-同线程回收"><a href="#2-2-1-同线程回收" class="headerlink" title="2.2.1  同线程回收"></a>2.2.1  同线程回收</h5><p>同线程回收指的是和Stack绑定的线程来调用stack.push()方法进行对象回收。上面说了，同线程回收的方法是pushNow()，我们来看看源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">private void pushNow(DefaultHandle&lt;?&gt; item) &#123;</span><br><span class="line">            &#x2F;&#x2F;判断Item是否已经被回收过</span><br><span class="line">            if (item.recycleId !&#x3D; 0 || !item.compareAndSetLastRecycledId(0, OWN_THREAD_ID)) &#123;</span><br><span class="line">                throw new IllegalStateException(&quot;recycled already&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            item.recycleId &#x3D; OWN_THREAD_ID;</span><br><span class="line"></span><br><span class="line">            int size &#x3D; this.size;</span><br><span class="line">            &#x2F;&#x2F;判断当前对象是否可以进行回收</span><br><span class="line">            if (size &gt;&#x3D; maxCapacity || dropHandle(item)) &#123;</span><br><span class="line">                &#x2F;&#x2F; Hit the maximum capacity or should drop - drop the possibly youngest object.</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            if (size &#x3D;&#x3D; elements.length) &#123;</span><br><span class="line">                elements &#x3D; Arrays.copyOf(elements, min(size &lt;&lt; 1, maxCapacity));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            elements[size] &#x3D; item;</span><br><span class="line">            this.size &#x3D; size + 1;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>这个方法主要步骤如下：</p>
<p>1）判断这个handle是否被回收过。</p>
<p>2）判断当前对象是否可以进行回收。这步中进行了两个判断，一个是size &gt; maxCapacity。这步很好理解，意思是如果当前Stack的对象数量已经达到了最大容量了，就不回收了。第二个判断是调用dropHandle(item)。这个方法的作用是判断是否需要回收该对象。在netty中，对象池是可以设置回收比例的，比如每8个对象回收一个，丢弃7个。dropHandle(item)方法就是判断传进来是item是该丢了还是该回收。如果回收比例是8的话，那么第一个对象需要回收，第2-8个对象丢弃，然后第九个对象需要回收….</p>
<p>3)如果当前Stack底层的elements数组已经满了，就扩容。扩容倍数是2倍，但需要判断是否到达最大容量。</p>
<p>4）把item梵高elements数组中，再把stack的size+1。</p>
<p>同线程回收的情况是比较简单的。就是简单的压栈。</p>
<h5 id="2-2-2-异线程回收"><a href="#2-2-2-异线程回收" class="headerlink" title="2.2.2 异线程回收"></a>2.2.2 异线程回收</h5><p>首先，回收指的是回收DefaultHandle，handle中包含真正的对象。然后，每个handle绑定了一个stack，而每个stack又绑定了一个线程。异线程回收的意思就是，不是由handle绑定的stack所绑定的线程来对这个handle进行回收！！！（甚至像绕口令）</p>
<p>在看pushLator这个方法之前我们先看一个类。WeakOrderQueue。它的结构如下：</p>
<p><img src="https://jurlyl.github.io/img/1615469863592-aa55ad22-8c2f-4d6d-b53e-84113e147034.png" alt="image.png"></p>
<p>首先可以看到，它的构造函数中传入了一个stack，所以，<strong>每个WeakOrderQueue其实是绑定了一个Stack的</strong>。</p>
<p>然后，WeakOrderQueue有两个内部类，Head和Link。这俩类是它底层的数据结构。先来看Link.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static final class Link extends AtomicInteger &#123;</span><br><span class="line">    final DefaultHandle&lt;?&gt;[] elements &#x3D; new DefaultHandle[LINK_CAPACITY];</span><br><span class="line"></span><br><span class="line">    int readIndex;</span><br><span class="line">    Link next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Link中有一个DefaultHandle&lt;?&gt;[] elements,这就是对象的容器。</p>
<p>再来看Head类：</p>
<p><img src="https://jurlyl.github.io/img/1615470401848-1c779110-2928-44f5-ba2c-9f6cb43ca637.png" alt="image.png"></p>
<p>Head类底层是Link。所以，可以把它当成一个特殊的Link。</p>
<p>而WeakOrderQueue底层是这俩类，所以WeakOrderQueue也只是一个存放Handle对象的容器。</p>
<p>OK，大致了解了WeakOrderQueue后，我们来看看pushLater方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">private void pushLater(DefaultHandle&lt;?&gt; item, Thread thread) &#123;</span><br><span class="line">            &#x2F;&#x2F;当maxDelayedQueues，代表stack允许的其他线程为自己创建的weakOrderQueue数量。为0就是不允许其他线程帮自己回收对象。</span><br><span class="line">            if (maxDelayedQueues &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                &#x2F;&#x2F; We don&#39;t support recycling across threads and should just drop the item on the floor.</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; we don&#39;t want to have a ref to the queue as the value in our weak map</span><br><span class="line">            &#x2F;&#x2F; so we null it out; to ensure there are no races with restoring it later</span><br><span class="line">            &#x2F;&#x2F; we impose a memory ordering here (no-op on x86)</span><br><span class="line">            &#x2F;&#x2F;这个map是个线程本地变量。存放当前线程为与其他线程绑定的stack而创建的weakOrderQueue</span><br><span class="line">            Map&lt;Stack&lt;?&gt;, WeakOrderQueue&gt; delayedRecycled &#x3D; DELAYED_RECYCLED.get();</span><br><span class="line">             &#x2F;&#x2F;拿到当前执行回收对象这个线程为stack创建的weakOrderQueue</span><br><span class="line">            WeakOrderQueue queue &#x3D; delayedRecycled.get(this);</span><br><span class="line">            &#x2F;&#x2F;下面这一部分就是把item放到weakOrderQueue中</span><br><span class="line">            if (queue &#x3D;&#x3D; null) &#123;</span><br><span class="line">                &#x2F;&#x2F;判断delayedRecycled这个map的容量是否达到最大值</span><br><span class="line">                if (delayedRecycled.size() &gt;&#x3D; maxDelayedQueues) &#123;</span><br><span class="line">                    &#x2F;&#x2F; Add a dummy queue so we know we should drop the object</span><br><span class="line">                    &#x2F;&#x2F;如果到达最大值，就丢给WeakOrderQueue.DUMMY进去，这个weakOrderQueue是个空的queue，不能进行对象回收。</span><br><span class="line">                    delayedRecycled.put(this, WeakOrderQueue.DUMMY);</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">                &#x2F;&#x2F; Check if we already reached the maximum number of delayed queues and if we can allocate at all.</span><br><span class="line">                &#x2F;&#x2F;否则，就创建一个weakOrderQueue，如果创建失败就直接返回</span><br><span class="line">                if ((queue &#x3D; newWeakOrderQueue(thread)) &#x3D;&#x3D; null) &#123;</span><br><span class="line">                    &#x2F;&#x2F; drop object</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">                &#x2F;&#x2F;如果创建成功，就把要回收的handle所绑定的stack作为key，刚刚创建的queue作为value放到delayedRecycled这个map中</span><br><span class="line">                &#x2F;&#x2F;如果这个线程下次再为同样一个stack回收对象，就不用再创建queue了，可以直接从delayedRecycled中取出来</span><br><span class="line">                delayedRecycled.put(this, queue);</span><br><span class="line">                &#x2F;&#x2F;判断queue是否是空queue</span><br><span class="line">            &#125; else if (queue &#x3D;&#x3D; WeakOrderQueue.DUMMY) &#123;</span><br><span class="line">                &#x2F;&#x2F; drop object</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;把item放到queue中</span><br><span class="line">            queue.add(item);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>这个方法步骤如下：</p>
<p>1）<strong>先判断这个item绑定的stack    是否允许     除了和它绑定的线程以外的线程    来回收     与它绑定的handle</strong>。(这样断句应该比较明白了吧哈哈哈)，换句话说就是 是否允许线程回收。如果不允许，就直接结束方法。</p>
<p>2）拿到delayedRecycled这个map，这个map是个线程本地变量，存放当前线程为了  其他线程绑定的stack  而创建的weakOrderQueue。key是Stack，value是WeakOrderQueue。</p>
<p>3）取出要回收的这个handle所绑定的Stack对应的weakOrderQueue,并赋值给变量queue。</p>
<p>4）判断queue是否为空。如果为空，且delayedRecycled中的元素个数没有到达最大容量时候，就新建一个queue。如果达到最大容量，就把一个不能进行回收的WeakOrderQueue(WeakOrderQueue.DUMMY)放到delayedRecycled去。</p>
<p><strong>注意：首先要知道，Stack这个类有一个<strong><strong>WeakOrderQueue类型的成员变量head，这个head可以和其他与当前stack绑定的WeakOrderQueue形成一条链表。</strong></strong>在这步中，<strong><strong>newWeakOrderQueue(thread))方法除了新建一个WeakOrderQueue以外，还把创建的出来的queue以头插的方式加入到了与当前回收的这个handle绑定的Stack的成员变量head所在的链表中。</strong></strong>后续，如果stack中没有对象可以拿了，就可以从weakOrderQueue链表中把对象转移到stack的底层数组中。</strong></p>
<p>5）如果不为空，且queue不是WeakOrderQueue.DUMMY，就把需要回收的handle放到queue中。</p>
<p>queue.add()方法就不贴出来了，就是weakOrderQueue底层的一些数据结构的操作。</p>
<p>到这儿，就把同线程和异线程回收对象说完了。上面还有个坑没填，那就是如何<strong>scavenge()方法</strong>怎么把被其他线程回收的对象转移到当前stack。</p>
<h4 id="2-3-把对象从WeakOrderQueue转移到Stack"><a href="#2-3-把对象从WeakOrderQueue转移到Stack" class="headerlink" title="2.3 把对象从WeakOrderQueue转移到Stack"></a>2.3 把对象从WeakOrderQueue转移到Stack</h4><p>在说这段以前，先看看Stack这个类的中的三个成员变量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">private WeakOrderQueue cursor, prev;</span><br><span class="line">private volatile WeakOrderQueue head;</span><br></pre></td></tr></table></figure>

<p>cursor表示当前操作的weakOrderQueue，prev是cursor的前一个queue。由于维护weakOrderQueue链表是头插的方式，所以还需要一个head头节点。</p>
<p>我们来看下scanvenge方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">private boolean scavenge() &#123;</span><br><span class="line">            &#x2F;&#x2F; continue an existing scavenge, if any</span><br><span class="line">            &#x2F;&#x2F;真正执行转移操作的方法</span><br><span class="line">            if (scavengeSome()) &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;如果没有任何对象移动成功，就把prev指针置为空，并且把当前WeakOrderQueue cursor的值改为head</span><br><span class="line">            &#x2F;&#x2F; reset our scavenge cursor</span><br><span class="line">            prev &#x3D; null;</span><br><span class="line">            cursor &#x3D; head;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>它的主要步骤就是调scavengeSome().那我们继续看scavengeSome()。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">private boolean scavengeSome() &#123;</span><br><span class="line">            WeakOrderQueue prev;</span><br><span class="line">            &#x2F;&#x2F;拿到当前Stack的cursor指向的weakOrderQueue</span><br><span class="line">            WeakOrderQueue cursor &#x3D; this.cursor;</span><br><span class="line">            &#x2F;&#x2F;如果cursor为空</span><br><span class="line">            if (cursor &#x3D;&#x3D; null) &#123;</span><br><span class="line">                prev &#x3D; null;</span><br><span class="line">                &#x2F;&#x2F;把head的值赋值给cursor</span><br><span class="line">                cursor &#x3D; head;</span><br><span class="line">                &#x2F;&#x2F;如果head都为空，说明当前Stack中没有WeakOrderQueue，也就没有其他线程回收的对象了，就直接返回了</span><br><span class="line">                if (cursor &#x3D;&#x3D; null) &#123;</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#x2F;&#x2F;如果cursor不为空，就把当前stack的prev成员变量赋值给上面声明的prev变量，这步有啥作用？</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                prev &#x3D; this.prev;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;转移成功的标志，只有当success为true，且cursor为空时候，下面的do while循环才会结束</span><br><span class="line">            boolean success &#x3D; false;</span><br><span class="line">            &#x2F;&#x2F;循环处理当前Stack的weakOrderQueue链表中的所有weakOrderQueue</span><br><span class="line">            &#x2F;&#x2F;把里面的对象转移到当前Stack</span><br><span class="line">            do &#123;</span><br><span class="line">                &#x2F;&#x2F;如果转移成功，就把success改为true，且跳出当前循环</span><br><span class="line">                if (cursor.transfer(this)) &#123;</span><br><span class="line">                    success &#x3D; true;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                &#x2F;&#x2F;处理下一个weakOrderQueue</span><br><span class="line">                WeakOrderQueue next &#x3D; cursor.getNext();</span><br><span class="line">                if (cursor.get() &#x3D;&#x3D; null) &#123;</span><br><span class="line">                    &#x2F;&#x2F; If the thread associated with the queue is gone, unlink it, after</span><br><span class="line">                    &#x2F;&#x2F; performing a volatile read to confirm there is no data left to collect.</span><br><span class="line">                    &#x2F;&#x2F; We never unlink the first queue, as we don&#39;t want to synchronize on updating the head.</span><br><span class="line">                    if (cursor.hasFinalData()) &#123;</span><br><span class="line">                        for (;;) &#123;</span><br><span class="line">                            &#x2F;&#x2F;transfer方法作用是把WeakOrderQueue底层的Link中的handle对象转移到stack底层的elements数组。</span><br><span class="line">                            if (cursor.transfer(this)) &#123;</span><br><span class="line">                                success &#x3D; true;</span><br><span class="line">                            &#125; else &#123;</span><br><span class="line">                                break;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    if (prev !&#x3D; null) &#123;</span><br><span class="line">                        &#x2F;&#x2F; Ensure we reclaim all space before dropping the WeakOrderQueue to be GC&#39;ed.</span><br><span class="line">                        cursor.reclaimAllSpaceAndUnlink();</span><br><span class="line">                        prev.setNext(next);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    prev &#x3D; cursor;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                cursor &#x3D; next;</span><br><span class="line"></span><br><span class="line">            &#125; while (cursor !&#x3D; null &amp;&amp; !success);</span><br><span class="line"></span><br><span class="line">            this.prev &#x3D; prev;</span><br><span class="line">            this.cursor &#x3D; cursor;</span><br><span class="line">            return success;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>代码中的注释已经比较详细了，这段的主要代码都是在操作weakOrderQueue链表，这儿就不多啰嗦了。负责把weakOrderQueue中的handle转移到stack底层的elements数组中的方法是WeakOrderQueue.transfer(Stack stack)。这个方法底层就是操作queue里的Link链表，然后把Link里的handle对象复制到Stack底层的elements数组中，代码就不贴了，可以自己去netty源码里看看。</p>
<p>最后再看看这个图，加深下印象~</p>
<p><img src="https://jurlyl.github.io/img/1615476744557-f88847ff-e775-4f1d-bd2d-6185ea7b4d3a.png" alt="netty-object-pool.png"></p>
<p>如果有错误的地方请指正~</p>
</div><div class="post-copyright"><script type="text/javascript" src="/js/copyright.js" successtext="Copy Successed!"></script><link rel="stylesheet" type="text/css" href="/css/copyright.css"><p><span>Title: </span>Netty对象池</p><p><span>Author: </span>jurly</p><p><span>Date: </span>2021-03-11</p><p><span>Last Update: </span>2021-03-12</p><p><span>Blog Link: </span><a href="/2021/03/11/netty对象池解析/">http://example.com/2021/03/11/netty%E5%AF%B9%E8%B1%A1%E6%B1%A0%E8%A7%A3%E6%9E%90/</a><span class="copy-path"><i class="fa fa-clipboard" data-clipboard-text="http://example.com/2021/03/11/netty%E5%AF%B9%E8%B1%A1%E6%B1%A0%E8%A7%A3%E6%9E%90/"></i></span></p><p><span>Copyright Declaration: </span>The author owns the copyright. Please indicate the source reproduced!</p></div><br><div class="tags"></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://example.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> Categories</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Netty/">Netty</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> Tags</i></div><div class="tagcloud"></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> Recent</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2021/03/11/netty%E5%AF%B9%E8%B1%A1%E6%B1%A0%E8%A7%A3%E6%9E%90/">Netty对象池</a></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2021 <a href="/." rel="nofollow">Jurly's Shell.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.css"><script type="text/javascript" src="/js/love.js"></script><script type="text/javascript" src="/js/copycode.js" successtext="Copy Successed!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>